#!/bin/bash
# ============================================================================
# Kubernetes Pod and Container Manager with FZF
# ============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Find the `build-pod-container-tables` library
find_lib() {
    local paths=(
        "${SCRIPT_DIR}/lib/build-pod-container-tables"
        "${HOME}/.local/lib/kselect/build-pod-container-tables"
        "/usr/local/lib/kselect/build-pod-container-tables"
    )

    for path in "${paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done

    echo "Error: Cannot find build-pod-container-tables library" >&2
    exit 1
}

LIB_PATH=$(find_lib)

# ============================================================================
# Configuration
# ============================================================================
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly CYAN='\033[0;36m'
readonly GRAY='\033[0;90m'
readonly MAGENTA='\033[0;35m'
readonly WHITE='\033[0;37m'
readonly RESET='\033[0m'

readonly CACHE_REFRESH_INTERVAL=30
readonly LOG_TAIL_LINES=100

# Global state
CONTEXT=""
NAMESPACE=""
BG_REFRESH_PID=""
CACHE_DIR=""
STATE_FILE=""

# ============================================================================
# Utility Functions
# ============================================================================
get_current_context() {
    kubectl config current-context
}

get_current_namespace() {
    local namespace
    namespace=$(kubectl config view --minify --output 'jsonpath={..namespace}')
    echo "${namespace:-default}"
}

error_exit() {
    echo "Error: $1" >&2
    exit 1
}

colorize() {
    local color="$1"
    local text="$2"
    case "$color" in
    RED) echo -e "${RED}${text}${RESET}" ;;
    GREEN) echo -e "${GREEN}${text}${RESET}" ;;
    YELLOW) echo -e "${YELLOW}${text}${RESET}" ;;
    CYAN) echo -e "${CYAN}${text}${RESET}" ;;
    GRAY) echo -e "${GRAY}${text}${RESET}" ;;
    MAGENTA) echo -e "${MAGENTA}${text}${RESET}" ;;
    WHITE) echo -e "${WHITE}${text}${RESET}" ;;
    *) echo "$text" ;;
    esac
}

check_dependencies() {
    local deps=("$@")
    for dep in "${deps[@]}"; do
        command -v "$dep" >/dev/null 2>&1 || error_exit "$dep is required but not installed"
    done
}

# ============================================================================
# State Management
# ============================================================================
save_state() {
    local mode="$1"
    local pod_name="${2:-}"
    echo "MODE=$mode" >"$STATE_FILE"
    echo "POD_NAME=$pod_name" >>"$STATE_FILE"
}

load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        source "$STATE_FILE"
        echo "${MODE:-pods}|${POD_NAME:-}"
    else
        echo "pods|"
    fi
}

# ============================================================================
# Cache Functions - Simplified
# ============================================================================
get_cache_file() {
    local file_type="$1"
    echo "${CACHE_DIR}/${file_type}"
}

refresh_cache() {
    mkdir -p "$CACHE_DIR"

    local raw_data_file=$(get_cache_file "raw_data.json")
    local temp_file=$(mktemp)

    # Single kubectl call to get all pod data with containers
    if ! kubectl get pods -o json >"$temp_file" 2>&1; then
        echo "Failed to fetch pod data" >&2
        rm -f "$temp_file"
        return 1
    fi

    mv "$temp_file" "$raw_data_file"

    # Process the data into different views
    if ! "$LIB_PATH" -i "$raw_data_file" -o "$CACHE_DIR"; then
        echo "Failed to process pod data" >&2
        return 1
    fi

    return 0
}

# ============================================================================
# Background Refresh
# ============================================================================
background_refresh() {
    while true; do
        sleep "$CACHE_REFRESH_INTERVAL"
        refresh_cache
    done
}

start_background_refresh() {
    background_refresh &
    BG_REFRESH_PID=$!
}

stop_background_refresh() {
    if [[ -n "$BG_REFRESH_PID" ]]; then
        kill "$BG_REFRESH_PID" 2>/dev/null || true
        wait "$BG_REFRESH_PID" 2>/dev/null || true
        BG_REFRESH_PID=""
    fi
}

cleanup() {
    stop_background_refresh
    rm -f "$STATE_FILE"
}

trap cleanup EXIT INT TERM

# ============================================================================
# Display Functions
# ============================================================================
list_pods() {
    local pods_file=$(get_cache_file "pods")

    if [[ ! -f "$pods_file" ]]; then
        refresh_cache
    fi

    echo "⎈ $(colorize YELLOW "$CONTEXT") | $(colorize YELLOW "$NAMESPACE")"
    echo "$(colorize MAGENTA "ENTER") to list containers, $(colorize MAGENTA "CTRL-E") to exec, $(colorize MAGENTA "CTRL-D") to describe, $(colorize MAGENTA "CTRL-K") to delete, $(colorize MAGENTA "CTRL-Y") to copy name, $(colorize MAGENTA "CTRL-R") to refresh, $(colorize MAGENTA "CTRL-Q") to quit"

    cat "$pods_file"
}

list_containers() {
    local pod_name="$1"
    local containers_file=$(get_cache_file "containers")

    if [[ ! -f "$containers_file" ]]; then
        refresh_cache
    fi

    # Header
    echo "⎈ $(colorize YELLOW "$CONTEXT") | $(colorize YELLOW "$NAMESPACE") | $(colorize YELLOW "$pod_name")"
    echo "$(colorize MAGENTA "ENTER") to view logs, $(colorize MAGENTA "CTRL-E") to exec, $(colorize MAGENTA "CTRL-D") to describe, $(colorize MAGENTA "ESC") to go up, $(colorize MAGENTA "CTRL-Q") to quit"
    head -1 "$containers_file" | awk '{print substr($0, index($0, $2))}'

    # Containers
    grep "${pod_name}" "$containers_file" | awk '{print substr($0, index($0, $2))}'
}

# ============================================================================
# FZF Display Functions
# ============================================================================
display_data() {
    local state=$(load_state)
    local mode=$(echo "$state" | cut -d'|' -f1)
    local pod_name=$(echo "$state" | cut -d'|' -f2)

    if [[ "$mode" == "pods" ]]; then
        list_pods
    elif [[ "$mode" == "containers" ]]; then
        list_containers "$pod_name"
    fi
}

# ============================================================================
# Action Functions
# ============================================================================
copy_to_clipboard() {
    local text="$1"
    if command -v pbcopy &>/dev/null; then
        echo "$text" | pbcopy
        echo "Copied '$text' to clipboard"
    elif command -v xclip &>/dev/null; then
        echo "$text" | xclip -selection clipboard
        echo "Copied '$text' to clipboard"
    elif command -v wl-copy &>/dev/null; then
        echo "$text" | wl-copy
        echo "Copied '$text' to clipboard"
    else
        echo "No clipboard utility found (pbcopy, xclip, or wl-copy)"
        return 1
    fi
}

exec_into_pod() {
    local pod="$1"
    echo "====================================================================="
    echo "Executing into pod: $pod"
    if kubectl exec -it "$pod" -- sh -c 'command -v bash >/dev/null && exec bash || exec sh'; then
        return 0
    else
        echo "Failed to exec into pod: $pod"
        echo "Press any key to continue..."
        read -n 1 -s
        return 1
    fi
}

exec_into_container() {
    local container="$1"
    local state=$(load_state)
    local pod_name=$(echo "$state" | cut -d'|' -f2)
    echo "====================================================================="
    echo "Executing into container: $container in pod: $pod_name"
    if kubectl exec -it "$pod_name" -c "$container" -- sh -c 'command -v bash >/dev/null && exec bash || exec sh'; then
        return 0
    else
        echo "Failed to exec into container: $container in pod: $pod_name"
        echo "Press any key to continue..."
        read -n 1 -s
        return 1
    fi
}

delete_pod() {
    local pod="$1"
    echo "====================================================================="
    echo "Deleting pod: $pod"
    kubectl delete pod "$pod"
}

describe_pod() {
    local pod="$1"
    echo "====================================================================="
    echo "Describing pod: $pod"
    kubectl describe pod "$pod" | less
}

describe_container() {
    local container="$1"
    local state=$(load_state)
    local pod_name=$(echo "$state" | cut -d'|' -f2)
    echo "====================================================================="
    echo "Describing container: $container in pod: $pod_name"
    kubectl describe pod "$pod_name" |
        awk -v container="$container" '
        /^Containers:/ || /^Init Containers:/ { in_containers = 1 }
        in_containers && $0 ~ "^  " container ":$" {
            found = 1
            print $0
            next
        }
        found && /^  [^ ]+:$/ && $0 !~ "^    " {
            found = 0
        }
        found && /^[^ ]/ {
            found = 0
            in_containers = 0
        }
        found { print }
    ' | less
}

highlight_logs() {
    awk -v red="$RED" -v yellow="$YELLOW" -v gray="$GRAY" -v reset="$RESET" '
        {
            printf "%s%s%s ", gray, $1, reset;
            msg = substr($0, index($0, $2));
            gsub(/ERROR/, red "ERROR" reset, msg);
            gsub(/WARN/, yellow "WARN" reset, msg);
            print msg;
        }'
}

view_logs() {
    local container="$1"
    local state=$(load_state)
    local pod_name=$(echo "$state" | cut -d'|' -f2)
    echo "====================================================================="
    echo "Viewing logs container: $container in pod: $pod_name"

    local log_dir="${CACHE_DIR}/${pod_name}"
    mkdir -p "$log_dir"
    local log_file="${log_dir}/${container}.log"

    # Cleanup function
    cleanup() {
        if [[ -n "${pid:-}" ]]; then
            kill "$pid" 2>/dev/null || true
        fi
        rm -f "$log_file"
    }

    # Set trap for cleanup
    trap cleanup EXIT INT TERM

    # Remove old log_file if exists
    rm -f "$log_file"

    # Build kubectl command
    local kubectl_cmd="kubectl logs $pod_name -c $container --timestamps --follow"

    # Start kubectl logs in background, writing to log_file
    {
        # Try current logs first
        if ! $kubectl_cmd 2>&1 | highlight_logs; then
            # If that fails and we haven't tried --previous yet, try it
            kubectl logs "$pod_name" -c "$container" --timestamps --follow --previous 2>&1 | highlight_logs
        fi
    } >"$log_file" &
    local pid=$!

    # Give kubectl a moment to start and check if it's still running
    sleep 0.2
    if ! kill -0 "$pid" 2>/dev/null; then
        echo "Error: Failed to start log streaming"
        cleanup
        return 1
    fi

    # Read from log_file with less
    less "$log_file"
}

# ============================================================================
# FZF Action Dispatcher
# ============================================================================
dispatch_action() {
    local action="$1"
    local target="$2"
    local state=$(load_state)
    local mode=$(echo "$state" | cut -d'|' -f1)
    local pod_name=$(echo "$state" | cut -d'|' -f2)

    case "$action" in
    "enter")
        if [[ "$mode" == "pods" ]]; then
            save_state "containers" "$target"
        elif [[ "$mode" == "containers" ]]; then
            view_logs "$target"
        fi
        ;;
    "exec")
        if [[ "$mode" == "pods" ]]; then
            exec_into_pod "$target"
        elif [[ "$mode" == "containers" ]]; then
            exec_into_container "$target"
        fi
        ;;
    "describe")
        if [[ "$mode" == "pods" ]]; then
            describe_pod "$target"
        elif [[ "$mode" == "containers" ]]; then
            describe_container "$target"
        fi
        ;;
    "delete")
        if [[ "$mode" == "pods" ]]; then
            delete_pod "$target" && refresh_cache
        fi
        ;;
    "copy")
        copy_to_clipboard "$target"
        ;;
    "refresh")
        refresh_cache
        ;;
    "back")
        if [[ "$mode" == "containers" ]]; then
            save_state "pods" ""
        fi
        ;;
    esac
}

# ============================================================================
# Export
# ============================================================================
# Export functions for fzf subshells
export -f colorize get_cache_file load_state save_state
export -f list_pods list_containers refresh_cache display_data
export -f copy_to_clipboard exec_into_pod exec_into_container
export -f delete_pod describe_pod describe_container view_logs highlight_logs
export -f dispatch_action

# Export constants
export RED GREEN YELLOW CYAN GRAY MAGENTA WHITE RESET
export LIB_PATH CACHE_DIR CONTEXT NAMESPACE STATE_FILE

# ============================================================================
# Main
# ============================================================================
main() {
    check_dependencies "fzf" "kubectl" "jq"

    CONTEXT=$(get_current_context) || error_exit "Failed to get current context"
    NAMESPACE=$(get_current_namespace)
    CACHE_DIR="/tmp/kselect/${CONTEXT}/${NAMESPACE}"
    STATE_FILE="${CACHE_DIR}/.state"

    # Initialize state
    mkdir -p "$CACHE_DIR"
    save_state "pods" ""

    start_background_refresh

    # Run fzf with reload bindings
    display_data | fzf \
        --no-multi \
        --ansi \
        --tiebreak=begin,index \
        --prompt="FZF> " \
        --height=100% \
        --header-lines=3 \
        --bind="enter:execute-silent(dispatch_action enter {1})+reload(display_data)" \
        --bind="ctrl-e:execute(dispatch_action exec {1})+reload(display_data)" \
        --bind="ctrl-d:execute(dispatch_action describe {1})+reload(display_data)" \
        --bind="ctrl-k:execute(dispatch_action delete {1})+reload(display_data)" \
        --bind="ctrl-y:execute-silent(dispatch_action copy {1})+reload(display_data)" \
        --bind="ctrl-r:execute-silent(dispatch_action refresh)+reload(display_data)" \
        --bind="esc:execute-silent(dispatch_action back)+reload(display_data)" \
        --bind="ctrl-q:abort"
}

main "$@"
