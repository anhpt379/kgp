#!/bin/bash
# ============================================================================
# Kubernetes Pod and Container Manager with FZF
# ============================================================================
set -euo pipefail

# ============================================================================
# Constants
# ============================================================================
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly CACHE_REFRESH_INTERVAL=30
readonly LOG_TAIL_LINES=100

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly CYAN='\033[0;36m'
readonly GRAY='\033[0;90m'
readonly MAGENTA='\033[0;35m'
readonly WHITE='\033[0;37m'
readonly RESET='\033[0m'

# Library paths
readonly LIB_SEARCH_PATHS=(
    "${SCRIPT_DIR}/lib/build-pod-container-tables"
    "${HOME}/.local/lib/kzf/build-pod-container-tables"
    "/usr/local/lib/kzf/build-pod-container-tables"
)

# ============================================================================
# Global Variables
# ============================================================================
CONTEXT=""
NAMESPACE=""
CACHE_DIR=""
STATE_FILE=""
FZF_PORT_FILE=""
BG_REFRESH_PID=""
LIB_PATH=""

# ============================================================================
# Core Functions
# ============================================================================
find_library() {
    for path in "${LIB_SEARCH_PATHS[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    echo "Error: Cannot find build-pod-container-tables library" >&2
    exit 1
}

check_dependencies() {
    local missing=()
    for cmd in "$@"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Error: Missing required commands: ${missing[*]}" >&2
        exit 1
    fi
}

colorize() {
    local color="$1"
    local text="$2"
    local color_code=""
    
    case "$color" in
        RED)     color_code="$RED" ;;
        GREEN)   color_code="$GREEN" ;;
        YELLOW)  color_code="$YELLOW" ;;
        CYAN)    color_code="$CYAN" ;;
        GRAY)    color_code="$GRAY" ;;
        MAGENTA) color_code="$MAGENTA" ;;
        WHITE)   color_code="$WHITE" ;;
        *)       echo "$text"; return ;;
    esac
    
    echo -e "${color_code}${text}${RESET}"
}

# ============================================================================
# Kubernetes Functions
# ============================================================================
get_current_context() {
    kubectl config current-context
}

get_current_namespace() {
    local namespace
    namespace=$(kubectl config view --minify --output 'jsonpath={..namespace}')
    echo "${namespace:-default}"
}

# ============================================================================
# State Management
# ============================================================================
save_state() {
    local mode="$1"
    local pod_name="${2:-}"
    cat > "$STATE_FILE" <<EOF
MODE=$mode
POD_NAME=$pod_name
EOF
}

load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        source "$STATE_FILE"
    fi
}

# ============================================================================
# Cache Management
# ============================================================================
refresh_cache() {
    mkdir -p "$CACHE_DIR"
    local raw_data_file="${CACHE_DIR}/raw_data.json"
    local temp_file=$(mktemp)
    
    if kubectl get pods -o json >"$temp_file" 2>&1; then
        mv "$temp_file" "$raw_data_file"
        "$LIB_PATH" -i "$raw_data_file" -o "$CACHE_DIR"
    else
        echo "Failed to fetch pod data" >&2
        rm -f "$temp_file"
        return 1
    fi
}

# ============================================================================
# Background Refresh
# ============================================================================
start_background_refresh() {
    while true; do
        refresh_cache

        # Trigger FZF reload if port file exists
        if [[ -f "$FZF_PORT_FILE" ]]; then
            local port=$(cat "$FZF_PORT_FILE" 2>/dev/null)
            if [[ -n "$port" ]]; then
                curl -XPOST localhost:$port -d 'reload(display_data)'
            fi
        fi
        sleep "$CACHE_REFRESH_INTERVAL"
    done &
    BG_REFRESH_PID=$!
}

stop_background_refresh() {
    if [[ -n "$BG_REFRESH_PID" ]]; then
        kill "$BG_REFRESH_PID" 2>/dev/null || true
        wait "$BG_REFRESH_PID" 2>/dev/null || true
        BG_REFRESH_PID=""
    fi
}

# ============================================================================
# Display Functions
# ============================================================================
show_pod_header() {
    echo "⎈ $(colorize YELLOW "$CONTEXT") > $(colorize YELLOW "$NAMESPACE")"
    echo "$(colorize MAGENTA "ENTER") list containers  $(colorize MAGENTA "CTRL-E") exec  $(colorize MAGENTA "CTRL-L") view logs  $(colorize MAGENTA "CTRL-D") describe  $(colorize MAGENTA "CTRL-K") delete  $(colorize MAGENTA "CTRL-Y") copy name  $(colorize MAGENTA "CTRL-R") refresh"
}

show_container_header() {
    echo "⎈ $(colorize YELLOW "$CONTEXT") > $(colorize YELLOW "$NAMESPACE") > $(colorize YELLOW "$POD_NAME")"
    echo "$(colorize MAGENTA "ENTER")/$(colorize MAGENTA "CTRL-L") view logs  $(colorize MAGENTA "ESC") go up  $(colorize MAGENTA "CTRL-E") exec  $(colorize MAGENTA "CTRL-D") describe  $(colorize MAGENTA "CTRL-Y") copy name  $(colorize MAGENTA "CTRL-R") refresh"
}

list_pods() {
    local pods_file="${CACHE_DIR}/pods"
    [[ ! -f "$pods_file" ]] && refresh_cache
    
    show_pod_header
    cat "$pods_file"
}

list_containers() {
    local containers_file="${CACHE_DIR}/containers"
    [[ ! -f "$containers_file" ]] && refresh_cache
    
    show_container_header
    head -1 "$containers_file" | awk '{print substr($0, index($0, $2))}'
    grep "${POD_NAME}" "$containers_file" | awk '{print substr($0, index($0, $2))}'
}

display_data() {
    load_state
    case "$MODE" in
        pods)       list_pods ;;
        containers) list_containers ;;
    esac
}

# ============================================================================
# Action Functions
# ============================================================================
copy_to_clipboard() {
    local text="$1"
    local clipboard_cmd=""
    
    if command -v pbcopy &>/dev/null; then
        clipboard_cmd="pbcopy"
    elif command -v xclip &>/dev/null; then
        clipboard_cmd="xclip -selection clipboard"
    elif command -v wl-copy &>/dev/null; then
        clipboard_cmd="wl-copy"
    else
        echo "No clipboard utility found"
        return 1
    fi
    
    echo "$text" | $clipboard_cmd
    echo "Copied '$text' to clipboard"
}

exec_shell() {
    local pod="$1"
    local container="${2:-}"
    local exec_cmd="kubectl exec -it $pod"
    
    [[ -n "$container" ]] && exec_cmd+=" -c $container"
    exec_cmd+=" -- sh -c 'command -v bash >/dev/null && exec bash || exec sh'"
    
    echo "====================================================================="
    echo "Executing into ${container:+container: $container in }pod: $pod"
    
    if eval "$exec_cmd"; then
        return 0
    else
        echo "Failed to exec into ${container:+container: $container in }pod: $pod"
        echo "Press any key to continue..."
        read -n 1 -s
        return 1
    fi
}

delete_pod() {
    local pod="$1"
    echo "====================================================================="
    echo "Deleting pod: $pod"
    kubectl delete pod "$pod"
}

describe_resource() {
    local resource_type="$1"
    local resource_name="$2"
    
    echo "====================================================================="
    echo "Describing $resource_type: $resource_name"
    
    if [[ "$resource_type" == "pod" ]]; then
        kubectl describe pod "$resource_name" | less
    else
        load_state
        kubectl describe pod "$POD_NAME" | \
            awk -v container="$resource_name" '
                /^Containers:/ || /^Init Containers:/ { in_containers = 1 }
                in_containers && $0 ~ "^  " container ":$" {
                    found = 1
                    print $0
                    next
                }
                found && /^  [^ ]+:$/ && $0 !~ "^    " { found = 0 }
                found && /^[^ ]/ { found = 0; in_containers = 0 }
                found { print }
            ' | less
    fi
}

highlight_logs() {
    awk 'BEGIN {
        # Color codes
        colors[0]=31; colors[1]=32; colors[2]=33; colors[3]=34; colors[4]=35; colors[5]=36
        colors[6]=91; colors[7]=92; colors[8]=93; colors[9]=94; colors[10]=95; colors[11]=96
        color_count = 12
        next_color = 0
    }
    {
        # Match pattern: [pod/container] timestamp message
        if (match($0, /^\[([^]]+)\] ([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]+Z) (.*)$/, parts)) {
            full_container = parts[1]
            timestamp = parts[2]
            message = parts[3]
            
            # Extract just the container name from pod/pod-name/container-name
            split(full_container, container_parts, "/")
            container = container_parts[length(container_parts)]
            
            # Assign color to container if not seen before
            if (!(container in container_colors)) {
                container_colors[container] = colors[next_color]
                next_color = (next_color + 1) % color_count
            }
            
            # Print with colors: timestamp first, then container, then message
            printf "\033[2m%s\033[0m \033[%dm%s\033[0m %s\n", 
                timestamp, container_colors[container], container, message
        } else {
            # Print non-matching lines as-is
            print $0
        }
    }'
}

view_logs() {
    local pod="$1"
    local container="${2:-}"
    local args=("$pod" "--follow" "--prefix" "--timestamps")

    [[ -n "$container" ]] && args+=("-c" "$container") || args+=("--all-containers" "--max-log-requests=20")

    if kubectl logs "${args[@]}" 2>&1 | highlight_logs | (less || true); then
        return 0
    else
        echo "Falling back to --previous logs..." >&2
        kubectl logs "${args[@]}" --previous 2>&1 | highlight_logs | (less || true)
    fi
}

# ============================================================================
# Action Dispatcher
# ============================================================================
dispatch() {
    local action="$1"
    local target="$2"
    load_state
    
    case "$action" in
        enter)
            if [[ "$MODE" == "pods" ]]; then
                save_state "containers" "$target"
            fi
            ;;
        exec)
            if [[ "$MODE" == "pods" ]]; then
                exec_shell "$target"
            else
                exec_shell "$POD_NAME" "$target"
            fi
            ;;
        describe)
            if [[ "$MODE" == "pods" ]]; then
                describe_resource "pod" "$target"
            else
                describe_resource "container" "$target"
            fi
            ;;
        delete)
            [[ "$MODE" == "pods" ]] && delete_pod "$target" && refresh_cache
            ;;
        copy)
            copy_to_clipboard "$target"
            ;;
        logs)
            if [[ "$MODE" == "pods" ]]; then
                view_logs "$target"
            else
                view_logs "$POD_NAME" "$target"
            fi
            ;;
        refresh)
            refresh_cache
            ;;
        back)
            [[ "$MODE" == "containers" ]] && save_state "pods"
            ;;
    esac
}

# ============================================================================
# Cleanup
# ============================================================================
cleanup() {
    stop_background_refresh
    rm -f "$STATE_FILE"
    rm -f "$FZF_PORT_FILE"
}

# ============================================================================
# Export Functions for FZF
# ============================================================================
export -f colorize load_state save_state
export -f show_pod_header show_container_header
export -f list_pods list_containers refresh_cache display_data
export -f copy_to_clipboard exec_shell delete_pod describe_resource
export -f view_logs highlight_logs dispatch

# Export variables
export RED GREEN YELLOW CYAN GRAY MAGENTA WHITE RESET
export LIB_PATH CACHE_DIR CONTEXT NAMESPACE STATE_FILE FZF_PORT_FILE MODE POD_NAME

# Setup
check_dependencies "kubectl" "fzf" "awk" "curl"
LIB_PATH=$(find_library)

# Initialize environment
CONTEXT=$(get_current_context) || { echo "Failed to get current context" >&2; exit 1; }
NAMESPACE=$(get_current_namespace)
CACHE_DIR="/tmp/kzf/${CONTEXT}/${NAMESPACE}"
STATE_FILE="${CACHE_DIR}/.state"
FZF_PORT_FILE="${CACHE_DIR}/.fzf-port"

# Initialize state
mkdir -p "$CACHE_DIR"
save_state "pods"

# Start UI if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Setup cleanup
    trap cleanup EXIT INT TERM
    
    # Start background refresh
    start_background_refresh
    
    # Run FZF interface
    # Note: CTRL-L is mapped to END in my terminal
    display_data | fzf \
        --no-multi \
        --ansi \
        --tiebreak=begin,index \
        --prompt="KZF> " \
        --height=100% \
        --header-lines=3 \
        --listen \
        --bind 'start:execute-silent:echo $FZF_PORT > $FZF_PORT_FILE' \
        --bind="enter:transform:grep -q MODE=containers $STATE_FILE && echo 'execute(dispatch logs {1})+reload(display_data)' || echo 'execute-silent(dispatch enter {1})+reload(display_data)+clear-query'" \
        --bind="ctrl-e:execute(dispatch exec {1})+reload(display_data)" \
        --bind="ctrl-d:execute(dispatch describe {1})+reload(display_data)" \
        --bind="ctrl-k:execute(dispatch delete {1})+reload(display_data)" \
        --bind="ctrl-y:execute-silent(dispatch copy {1})+reload(display_data)" \
        --bind="ctrl-r:execute-silent(dispatch refresh)+reload(display_data)" \
        --bind="end:execute(dispatch logs {1})+reload(display_data)" \
        --bind="esc:transform:grep -q MODE=pods $STATE_FILE && echo abort || echo 'execute-silent(dispatch back)+reload(display_data)+clear-query'"
fi

