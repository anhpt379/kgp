#!/bin/bash
# ============================================================================
# Kubernetes Pod and Container Manager with FZF
# ============================================================================
set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly CYAN='\033[0;36m'
readonly GRAY='\033[0;90m'
readonly MAGENTA='\033[0;35m'
readonly WHITE='\033[0;37m'
readonly RESET='\033[0m'

readonly CACHE_DIR="/tmp/kgp"
readonly CACHE_REFRESH_INTERVAL=30
readonly LOG_TAIL_LINES=100

# Global state
CONTEXT=""
NAMESPACE=""
POD_NAME=""
BG_REFRESH_PID=""

# Cache files
PODS_CACHE=""
CONTAINERS_CACHE=""
RAW_DATA_CACHE=""

# ============================================================================
# Utility Functions
# ============================================================================
get_current_context() {
    kubectl config current-context
}

get_current_namespace() {
    local namespace
    namespace=$(kubectl config view --minify --output 'jsonpath={..namespace}')
    echo "${namespace:-default}"
}

error_exit() {
    echo "Error: $1" >&2
    exit 1
}

colorize() {
    local color="$1"
    local text="$2"
    case "$color" in
    RED) echo -e "${RED}${text}${RESET}" ;;
    GREEN) echo -e "${GREEN}${text}${RESET}" ;;
    YELLOW) echo -e "${YELLOW}${text}${RESET}" ;;
    CYAN) echo -e "${CYAN}${text}${RESET}" ;;
    GRAY) echo -e "${GRAY}${text}${RESET}" ;;
    MAGENTA) echo -e "${MAGENTA}${text}${RESET}" ;;
    WHITE) echo -e "${WHITE}${text}${RESET}" ;;
    *) echo "$text" ;;
    esac
}

check_dependencies() {
    local deps=("$@")
    for dep in "${deps[@]}"; do
        command -v "$dep" >/dev/null 2>&1 || error_exit "$dep is required but not installed"
    done
}

# ============================================================================
# Data Fetching
# ============================================================================
fetch_data() {
    local temp_file=$(mktemp)

    # Single kubectl call to get all pod data with containers
    if ! kubectl get pods -o json >"$temp_file" 2>&1; then
        echo "Failed to fetch pod data" >&2
        rm -f "$temp_file"
        return 1
    fi

    mv "$temp_file" "$RAW_DATA_CACHE"

    # Process the data into different views
    generate_pod_list
    generate_container_list
}

generate_pod_list() {
    python3 process_pods.py "$RAW_DATA_CACHE" -o "$PODS_CACHE"
}

generate_container_list() {
    python3 process_containers.py "$RAW_DATA_CACHE" -o "$CONTAINERS_CACHE"
}

get_pod_containers() {
    local pod_name="$1"
    grep "^${pod_name}[[:space:]]" "$CONTAINERS_CACHE" | cut -f2-
}

# ============================================================================
# Cache Management
# ============================================================================
init_cache_files() {
    local cache_base="${CACHE_DIR}/${CONTEXT}/${NAMESPACE}"
    mkdir -p "$cache_base"

    PODS_CACHE="${cache_base}/pods.tsv"
    CONTAINERS_CACHE="${cache_base}/containers.tsv"
    RAW_DATA_CACHE="${cache_base}/raw_data.json"
}

refresh_cache() {
    fetch_data 2>/dev/null || echo "Failed to refresh cache" >&2
}

background_refresh() {
    while true; do
        sleep "$CACHE_REFRESH_INTERVAL"
        fetch_data 2>/dev/null || true
    done
}

start_background_refresh() {
    background_refresh &
    BG_REFRESH_PID=$!
}

stop_background_refresh() {
    if [[ -n "$BG_REFRESH_PID" ]]; then
        kill "$BG_REFRESH_PID" 2>/dev/null || true
        wait "$BG_REFRESH_PID" 2>/dev/null || true
        BG_REFRESH_PID=""
    fi
}

cleanup() {
    stop_background_refresh
}

trap cleanup EXIT INT TERM

# ============================================================================
# Display Functions
# ============================================================================
colorize_pod_line() {
    local line="$1"

    # Skip header line
    if [[ "$line" =~ ^NAME ]]; then
        echo "$line"
        return
    fi

    local name=$(echo "$line" | awk '{print $1}')
    local ready=$(echo "$line" | awk '{print $2}')
    local status=$(echo "$line" | awk '{print $3}')
    local restarts=$(echo "$line" | awk '{print $4}')
    local age=$(echo "$line" | awk '{print $5}')

    # Extract ready and total counts
    local ready_count=0
    local total_count=0
    if [[ "$ready" =~ ^([0-9]+)/([0-9]+)$ ]]; then
        ready_count="${BASH_REMATCH[1]}"
        total_count="${BASH_REMATCH[2]}"
    fi

    case "$status" in
    *Error* | *Failed* | *CrashLoopBackOff*)
        printf "$(colorize RED "%-60s %-10s %-15s") " "$name" "$ready" "$status"
        if [[ "$restarts" -gt 0 ]]; then
            printf "$(colorize YELLOW "%-10s") " "$restarts"
        else
            printf "%-10s " "$restarts"
        fi
        printf "%s\n" "$age"
        ;;
    *Completed* | *Terminated* | *Succeeded*)
        colorize GRAY "$line"
        ;;
    *Pending*)
        colorize YELLOW "$line"
        ;;
    *ContainerCreating*)
        colorize CYAN "$line"
        ;;
    *Running*)
        # Check if all containers are ready
        if [[ "$ready_count" -eq "$total_count" ]] && [[ "$total_count" -gt 0 ]]; then
            # All containers ready - show status in green
            printf "$(colorize WHITE "%-60s") $(colorize WHITE "%-10s") $(colorize GREEN "%-15s") " "$name" "$ready" "$status"
            if [[ "$restarts" -gt 0 ]]; then
                printf "$(colorize YELLOW "%-10s") " "$restarts"
            else
                printf "%-10s " "$restarts"
            fi
            printf "%s\n" "$age"
        else
            # Not all containers ready - show status in yellow
            printf "$(colorize WHITE "%-60s") $(colorize YELLOW "%-10s") $(colorize YELLOW "%-15s") " "$name" "$ready" "$status"
            if [[ "$restarts" -gt 0 ]]; then
                printf "$(colorize YELLOW "%-10s") " "$restarts"
            else
                printf "%-10s " "$restarts"
            fi
            printf "%s\n" "$age"
        fi
        ;;
    *NotReady*)
        printf "$(colorize WHITE "%-60s") $(colorize YELLOW "%-10s") $(colorize YELLOW "%-15s") " "$name" "$ready" "$status"
        if [[ "$restarts" -gt 0 ]]; then
            printf "$(colorize YELLOW "%-10s") " "$restarts"
        else
            printf "%-10s " "$restarts"
        fi
        printf "%s\n" "$age"
        ;;
    *)
        echo "$line"
        ;;
    esac
}

colorize_container_line() {
    local line="$1"

    # Skip header line
    if [[ "$line" =~ ^NAME ]]; then
        echo "$line"
        return
    fi

    local name=$(echo "$line" | awk '{print $1}')
    local ready=$(echo "$line" | awk '{print $2}')
    local status=$(echo "$line" | awk '{print $3}')
    local image=$(echo "$line" | awk '{$1=$2=$3=""; print $0}' | sed 's/^[[:space:]]*//')

    case "$status" in
    Error | CrashLoopBackOff | OOMKilled)
        printf "$(colorize RED "%-40s %-10s %-15s %s")\n" "$name" "$ready" "$status" "$image"
        ;;
    Completed | Terminated)
        colorize GRAY "$line"
        ;;
    Running)
        if [[ "$ready" == "true" ]]; then
            printf "$(colorize WHITE "%-40s") $(colorize GREEN "%-10s") $(colorize GREEN "%-15s") $(colorize GRAY "%s")\n" "$name" "$ready" "$status" "$image"
        else
            printf "$(colorize WHITE "%-40s") $(colorize YELLOW "%-10s") $(colorize YELLOW "%-15s") $(colorize GRAY "%s")\n" "$name" "$ready" "$status" "$image"
        fi
        ;;
    Waiting | Pending | ContainerCreating | PodInitializing)
        printf "$(colorize WHITE "%-40s") $(colorize YELLOW "%-10s") $(colorize YELLOW "%-15s") $(colorize GRAY "%s")\n" "$name" "$ready" "$status" "$image"
        ;;
    *)
        echo "$line"
        ;;
    esac
}

format_pods_output() {
    {
        printf "%-60s %-10s %-15s %-10s %s\n" "NAME" "READY" "STATUS" "RESTARTS" "AGE"
        while IFS=$'\t' read -r name ready status restarts age; do
            printf "%-60s %-10s %-15s %-10s %s\n" "$name" "$ready" "$status" "$restarts" "$age"
        done <"$PODS_CACHE"
    }
}

format_containers_output() {
    local pod_name="$1"
    {
        printf "%-40s %-10s %-15s %s\n" "NAME" "READY" "STATUS" "IMAGE"
        get_pod_containers "$pod_name" | while IFS=$'\t' read -r name type ready status image; do
            printf "%-40s %-10s %-15s %s\n" "$name" "$ready" "$status" "$image"
        done
    }
}

list_pods() {
    if [[ ! -f "$PODS_CACHE" ]]; then
        refresh_cache
    fi

    format_pods_output | while IFS= read -r line; do
        colorize_pod_line "$line"
    done
}

list_containers() {
    local pod_name="$1"
    if [[ ! -f "$CONTAINERS_CACHE" ]]; then
        refresh_cache
    fi

    format_containers_output "$pod_name" | while IFS= read -r line; do
        colorize_container_line "$line"
    done
}

# ============================================================================
# Action Functions
# ============================================================================
copy_to_clipboard() {
    local text="$1"
    if command -v pbcopy &>/dev/null; then
        echo "$text" | pbcopy
        echo "Copied '$text' to clipboard"
    elif command -v xclip &>/dev/null; then
        echo "$text" | xclip -selection clipboard
        echo "Copied '$text' to clipboard"
    elif command -v wl-copy &>/dev/null; then
        echo "$text" | wl-copy
        echo "Copied '$text' to clipboard"
    else
        echo "No clipboard utility found (pbcopy, xclip, or wl-copy)"
        return 1
    fi
}

exec_into_pod() {
    local pod="$1"
    echo "Executing into pod: $pod"
    # TODO: echo the full working kubectl command to screen before entering
    kubectl exec -it "$pod" -- bash 2>/dev/null ||
        kubectl exec -it "$pod" -- sh 2>/dev/null ||
        echo "Failed to exec into pod $pod"
}

exec_into_container() {
    local container="$1"
    echo "Executing into container: $container in pod: $POD_NAME"
    kubectl exec -it "$POD_NAME" -c "$container" -- bash 2>/dev/null ||
        kubectl exec -it "$POD_NAME" -c "$container" -- sh 2>/dev/null ||
        echo "Failed to exec into container $container"
}

describe_pod() {
    local pod="$1"
    echo "Describing pod: $pod"
    kubectl describe pod "$pod" | less
}

describe_container() {
    local container="$1"
    echo "Describing container: $container in pod: $POD_NAME"

    # Get the kubectl describe output and extract the specific container section
    kubectl describe pod "$POD_NAME" |
        awk -v container="$container" '
        # Start capturing when we find either containers section
        /^Containers:/ || /^Init Containers:/ { in_containers = 1 }

        # Found the target container (2 spaces + container name + colon)
        in_containers && $0 ~ "^  " container ":$" {
            found = 1
            print $0
            next
        }

        # Stop capturing when we hit another container at same level
        found && /^  [^ ]+:$/ && $0 !~ "^    " {
            found = 0
        }

        # Stop capturing when we hit a new top-level section
        found && /^[^ ]/ {
            found = 0
            in_containers = 0
        }

        # Print lines while in the target container section
        found { print }
    ' | less
}

view_logs() {
    local container="$1"
    echo "Viewing logs for container: $container in pod: $POD_NAME"
    echo ""
    echo "Controls:"
    echo "  - Press 'F' (Shift+F) to toggle follow mode"
    echo "  - Press 'Ctrl+C' to exit follow mode"
    echo "  - Press 'q' to quit"
    echo "  - Use '/' to search"
    echo "  - Use 'g' to go to beginning, 'G' to go to end"
    echo ""

    # View logs with less in follow mode (+F flag)
    # User can press Ctrl+C to stop following and browse normally
    # Then press F to resume following
    kubectl logs "$POD_NAME" -c "$container" --tail="$LOG_TAIL_LINES" -f | less

    echo ""
    echo "Returning to container view..."
}
# ============================================================================
# UI Functions
# ============================================================================
# TODO: Have a better/prettier context & action header
build_context_header() {
    echo -e "Context: $CONTEXT"
}

build_actions_header() {
    local actions=("$@")
    local header_parts=()

    for action in "${actions[@]}"; do
        case "$action" in
        "enter:containers") header_parts+=("$(colorize MAGENTA "ENTER") containers") ;;
        "enter:logs") header_parts+=("$(colorize MAGENTA "ENTER") logs") ;;
        "exec") header_parts+=("$(colorize MAGENTA "CTRL-E") exec") ;;
        "describe") header_parts+=("$(colorize MAGENTA "CTRL-D") describe") ;;
        "copy") header_parts+=("$(colorize MAGENTA "CTRL-Y") copy") ;;
        "refresh") header_parts+=("$(colorize MAGENTA "CTRL-R") refresh") ;;
        "back") header_parts+=("$(colorize MAGENTA "ESC") back") ;;
        esac
    done

    # Join with " | "
    local IFS=" | "
    echo -e "${header_parts[*]}"
}

build_pod_prompt() {
    echo "$(colorize CYAN "$NAMESPACE")> "
}

build_container_prompt() {
    echo "$(colorize CYAN "$NAMESPACE")/$(colorize YELLOW "$POD_NAME")> "
}

manage_pods() {
    start_background_refresh
    while true; do
        local context_header actions_header full_header prompt

        context_header=$(build_context_header)
        actions_header=$(build_actions_header "enter:containers" "exec" "describe" "copy" "refresh")
        full_header="${context_header}"$'\n'"${actions_header}"
        prompt=$(build_pod_prompt)

        local fzf_output
        # TODO: show all lines at once for listing pods
        fzf_output=$(list_pods | fzf \
            --no-multi \
            --ansi \
            --prompt="$prompt" \
            --height=100% \
            --header="$full_header" \
            --header-lines=1 \
            --bind="ctrl-e:execute(exec_into_pod {1})+abort" \
            --bind="ctrl-d:execute(describe_pod {1})" \
            --bind="ctrl-y:execute(copy_to_clipboard {1})" \
            --bind="ctrl-r:reload(list_pods)" \
            --print-query --expect=enter 2>/dev/null) || {
            break
        }

        # Parse fzf output
        local query=$(echo "$fzf_output" | sed -n '1p')
        local key=$(echo "$fzf_output" | sed -n '2p')
        local selection=$(echo "$fzf_output" | sed -n '3p')

        # Handle selection
        if [[ -n "$selection" && "$key" == "enter" ]]; then
            local pod_name=$(echo "$selection" | awk '{print $1}')
            manage_containers "$pod_name"
        fi
    done
    stop_background_refresh
}

manage_containers() {
    local pod_name="$1"
    POD_NAME="$pod_name"

    while true; do
        local context_header actions_header full_header prompt

        context_header=$(build_context_header)
        actions_header=$(build_actions_header "enter:logs" "exec" "describe" "copy" "refresh" "back")
        full_header="${context_header}"$'\n'"${actions_header}"
        prompt=$(build_container_prompt)

        local fzf_output
        # TODO: show all lines at once for listing containers
        fzf_output=$(list_containers "$pod_name" | fzf \
            --no-multi \
            --ansi \
            --prompt="$prompt" \
            --height=100% \
            --header="$full_header" \
            --header-lines=1 \
            --bind="ctrl-e:execute(exec_into_container {1})+abort" \
            --bind="ctrl-d:execute(describe_container {1})" \
            --bind="ctrl-y:execute(copy_to_clipboard {1})" \
            --bind="ctrl-r:reload(list_containers $pod_name)" \
            --print-query --expect=enter,esc 2>/dev/null) || {
            break
        }

        # Parse fzf output
        local query=$(echo "$fzf_output" | sed -n '1p')
        local key=$(echo "$fzf_output" | sed -n '2p')
        local selection=$(echo "$fzf_output" | sed -n '3p')

        # Handle exit conditions
        if [[ "$key" == "esc" ]]; then
            break
        fi

        # Handle selection
        if [[ -n "$selection" && "$key" == "enter" ]]; then
            local container_name=$(echo "$selection" | awk '{print $1}')
            view_logs "$container_name"
        fi
    done
}

# ============================================================================
# Initialize and Export
# ============================================================================
init_globals() {
    CONTEXT=$(get_current_context) || error_exit "Failed to get current context"
    NAMESPACE=$(get_current_namespace)
    init_cache_files
}

# Export functions and variables for fzf subshells
export -f colorize
export -f get_pod_containers
export -f colorize_pod_line colorize_container_line
export -f format_pods_output format_containers_output
export -f list_pods list_containers refresh_cache fetch_data
export -f generate_pod_list generate_container_list
export -f copy_to_clipboard exec_into_pod exec_into_container
export -f describe_pod describe_container view_logs

# Export color constants
export RED GREEN YELLOW CYAN GRAY MAGENTA WHITE RESET

# Export cache file paths and other variables
export CACHE_DIR CONTEXT NAMESPACE POD_NAME
export PODS_CACHE CONTAINERS_CACHE RAW_DATA_CACHE

# ============================================================================
# Main
# ============================================================================
main() {
    check_dependencies "fzf" "kubectl" "jq"

    init_globals

    # Initial data fetch
    if ! fetch_data; then
        error_exit "Failed to fetch initial data"
    fi

    manage_pods
}

main "$@"
